"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaStorage = void 0;
const node_fs_1 = require("node:fs");
const node_crypto_1 = require("node:crypto");
const node_os_1 = require("node:os");
const node_path_1 = require("node:path");
const media_probe_1 = require("media-probe");
class MediaStorage {
    constructor(options) {
        this.options = options;
        this.getDestination = options.destination || this.getDefaultDestination;
        this.getFilename = options.filename || this.getDefaultFilename;
        this.algorithm = options.algorithm || 'sha256';
        this.algorithmEncoding = options.algorithmEncoding || 'base64url';
    }
    getDefaultDestination(req, file, callback) {
        callback(null, node_os_1.default.tmpdir());
    }
    getDefaultFilename(req, file, callback) {
        callback(null, (0, node_crypto_1.randomBytes)(16).toString('hex'));
    }
    _handleFile(req, file, callback) {
        this.getDestination(req, file, (errDestination, destination) => {
            if (errDestination) {
                return callback(errDestination, file);
            }
            this.getFilename(req, file, (errFilename, filename) => {
                if (errFilename) {
                    return callback(errFilename, file);
                }
                const destinationPath = (0, node_path_1.resolve)(destination);
                const finalPath = (0, node_path_1.resolve)(destinationPath, filename);
                const outStream = (0, node_fs_1.createWriteStream)(finalPath);
                const md5sum = (0, node_crypto_1.createHash)(this.algorithm);
                if (this.options.open) {
                    file.stream.on('open', () => {
                        this.options.open(req, file, outStream);
                    });
                }
                file.stream.on('error', callback);
                file.stream.on('data', (chunk) => {
                    md5sum.update(chunk);
                    if (this.options.data) {
                        this.options.data(req, file, outStream, chunk);
                    }
                });
                file.stream.pipe(outStream);
                outStream.on('finish', () => {
                    let media;
                    const hash = md5sum.end().digest(this.algorithmEncoding);
                    file.hash = hash;
                    if (this.options.finish) {
                        this.options.finish(req, file, outStream);
                    }
                    (0, media_probe_1.ffprobe)(finalPath, {
                        showFormat: true,
                        showStreams: true,
                        showFrames: false,
                        showPackets: false,
                        showPrograms: false,
                        countFrames: false,
                        countPackets: false,
                    })
                        .then((probe) => {
                        media = probe;
                    })
                        .catch(() => { })
                        .finally(() => {
                        callback(null, {
                            destination: destinationPath,
                            filename,
                            path: finalPath,
                            size: outStream.bytesWritten,
                            hash,
                            media,
                        });
                    });
                });
            });
        });
    }
    _removeFile(req, file, callback) {
        const { path } = file;
        delete file.destination;
        delete file.filename;
        delete file.path;
        (0, node_fs_1.unlink)(path, callback);
        (0, node_fs_1.unlink)(file.path, callback);
    }
}
exports.MediaStorage = MediaStorage;
exports.default = (options) => new MediaStorage(options);
//# sourceMappingURL=index.js.map